CONTESTO
Pagina admin “Service Planning” (/admin/service-planning).
Stack backend: Laravel + MySQL/MariaDB.
Il frontend invia modifiche aggregate tramite UN’UNICA azione di salvataggio (“Save”).

Questo prompt definisce:
- formato delle request POST
- validazioni obbligatorie
- ordine delle operazioni backend
- gestione working_days, time_slots e orders
- gestione ordini REJECTED
- garanzie transazionali

NON introdurre nuove regole.
NON rendere retroattive le modifiche.
Rispettare rigorosamente le regole temporali già definite.

------------------------------------------------
PRINCIPIO FONDAMENTALE (VINCOLANTE)
------------------------------------------------

Il backend è la **source of truth**.

Il backend:
- valida SEMPRE le richieste
- rifiuta qualsiasi modifica illegale
- applica modifiche SOLO a giorni futuri
- garantisce consistenza atomica dei dati

------------------------------------------------
ENDPOINT
------------------------------------------------

POST /admin/service-planning/save

- accessibile solo ad admin
- protetto da middleware auth + admin
- tutte le modifiche passano da qui

------------------------------------------------
STRUTTURA DEL PAYLOAD (OBBLIGATORIA)
------------------------------------------------

Il frontend invia SEMPRE lo stato finale desiderato
(per i soli elementi modificabili).

Esempio payload JSON:

{
  "week_start": "2026-01-19",
  "week_end": "2026-01-25",

  "global_constraints": {
    "max_orders_per_slot": 10,
    "max_pending_time": 20,
    "location": "Piazza Centrale"
  },

  "days": [
    {
      "date": "2026-01-21",
      "is_working": true,
      "start_time": "11:00",
      "end_time": "15:00"
    },
    {
      "date": "2026-01-22",
      "is_working": false
    }
  ]
}

NOTE IMPORTANTI:
- Il frontend:
  - NON invia giorni ≤ oggi
  - NON invia settimane passate
- Il backend NON deve fidarsi:
  - deve ricontrollare tutto

------------------------------------------------
VALIDAZIONI BACKEND (OBBLIGATORIE)
------------------------------------------------

Prima di qualsiasi modifica:

1) Verificare che la settimana NON sia passata
2) Per ogni giorno nel payload:
   - il giorno deve essere > oggi
3) Verificare che:
   - start_time < end_time
   - la durata sia >= durata time slot
4) Se una qualsiasi validazione fallisce:
   - abortire
   - rollback completo
   - risposta errore

------------------------------------------------
FLUSSO BACKEND — ORDINE VINCOLANTE
------------------------------------------------

TUTTO deve avvenire in TRANSAZIONE DB.

--------------------------------
STEP 1 — CARICAMENTO STATO ATTUALE
--------------------------------

- Recuperare:
  - working_days esistenti della settimana
  - time_slots associati
  - ordini associati ai time slot

--------------------------------
STEP 2 — GLOBAL CONSTRAINTS
--------------------------------

I global constraints NON hanno tabella dedicata.
Sono applicati ai time slot FUTURI.

Azioni:
- per ogni time slot FUTURO coinvolto:
  - aggiornare:
    - max_orders
    - max_pending_time
    - location

RIDUZIONE CAPIENZA:
- se max_orders diminuisce:
  - per ogni time slot:
    - ordinare gli ordini per numero ordine crescente
    - mantenere i primi N
    - marcare come REJECTED tutti gli altri

--------------------------------
STEP 3 — GESTIONE GIORNI
--------------------------------

Per ogni giorno FUTURO della settimana:

CASO A — GIORNO NON ESISTE + is_working = true
→ CREAZIONE GIORNO

1) Creare working_day
2) Generare time_slots:
   - da start_time
   - a end_time (end escluso)
   - intervallo = durata time slot
3) Per ogni time slot:
   - applicare global constraints

--------------------------------

CASO B — GIORNO ESISTE + is_working = false
→ CANCELLAZIONE GIORNO

1) Per ogni time slot del giorno:
   - marcare TUTTI gli ordini come REJECTED
2) Cancellare tutti i time slot
3) Cancellare il working_day

--------------------------------

CASO C — GIORNO ESISTE + is_working = true
→ MODIFICA GIORNO

Confrontare:
- orari esistenti
- orari ricevuti

SUBCASO C1 — RIDUZIONE ORARIO

Esempio:
- prima: 10:00–17:00
- dopo: 10:00–12:00

Azioni:
1) Individuare time slot fuori dal nuovo range
2) Per ciascun time slot:
   - marcare ordini come REJECTED
3) Cancellare i time slot fuori range

SUBCASO C2 — ESTENSIONE ORARIO

Esempio:
- prima: 10:00–12:00
- dopo: 10:00–15:00

Azioni:
1) Generare i nuovi time slot mancanti
2) Applicare global constraints
3) NON toccare i time slot esistenti

--------------------------------
STEP 4 — INVARIANTI FINALI
--------------------------------

- Nessun ordine REJECTED può tornare attivo
- Nessuna modifica su giorni ≤ oggi
- Nessuna modifica su settimane passate
- Nessuna modifica parziale (atomicità)

--------------------------------
RISPOSTA BACKEND
--------------------------------

In caso di successo:
- status 200
- payload con:
  - stato aggiornato della settimana
  - working_days risultanti
  - time_slots risultanti

In caso di errore:
- status 4xx / 5xx
- nessuna modifica persistita

--------------------------------
LOGGING (OBBLIGATORIO)
--------------------------------

Loggare:
- giorni creati
- giorni cancellati
- time slot creati
- time slot cancellati
- ordini marcati REJECTED (conteggio)

--------------------------------
OBIETTIVO DI QUESTO PROMPT
--------------------------------

Definire in modo NON ambiguo:
- struttura delle request POST
- ordine delle operazioni backend
- gestione coerente di giorni, slot e ordini
- garanzie di consistenza dei dati

NON implementare frontend.
NON cambiare schema DB se non strettamente necessario.
