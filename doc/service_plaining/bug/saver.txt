CONTESTO
Pagina admin ‚ÄúService Planning‚Äù (/admin/service-planning).
Frontend: Blade + Tailwind + JS vanilla.
Architettura vincolante:
- state.js (SSOT)
- actions.js (eventi)
- render.js (state ‚Üí DOM)
- api.js (POST)
- hydration.js (bootstrap + snapshot)

Questo prompt descrive ESCLUSIVAMENTE:
- quando il pulsante Save deve essere abilitato/disabilitato
- come calcolare correttamente il dirty-state
- quali campi partecipano al confronto
- come gestire il caso ‚Äúsettimana senza dati DB‚Äù (default)

NON implementare backend completo.
NON modificare UI oltre ci√≤ che serve per Save.

------------------------------------------------
REGOLE TEMPORALI (VINCOLANTI)
------------------------------------------------

- Settimane passate:
  - Save DEVE essere DISABLED sempre (anche se l‚Äôutente prova a cambiare qualcosa)
  - la UI deve essere non editabile (ma questo √® gi√† gestito altrove)

- Settimana corrente:
  - Save pu√≤ essere ENABLED solo se:
    - esistono cambiamenti effettivi nel draft
    - e tali cambiamenti hanno effetto SOLO su giorni > oggi
  - cambiamenti su giorni <= oggi NON devono essere permessi e non devono entrare nel dirty

- Settimane future:
  - Save pu√≤ essere ENABLED se ci sono cambiamenti effettivi nel draft

------------------------------------------------
SAVE √à GLOBALE (VINCOLANTE)
------------------------------------------------

Esiste UN SOLO pulsante Save che salva:
- Global Variables
- Stati dei giorni (on/off)
- Fasce orarie start/end dei giorni

Il Save non √® legato a un singolo giorno.

------------------------------------------------
COSA CONTA COME ‚ÄúCAMBIAMENTO‚Äù (DIRTY-STATE)
------------------------------------------------

Il dirty-state deve considerare l‚Äôintera configurazione salvabile della settimana:

A) GLOBAL VARIABLES (tutte)
- max_orders_per_slot
- max_pending_time
- location

B) GIORNI (solo quelli modificabili)
Per ciascun giorno con date > oggi:
- is_working
- start_time (se is_working = true)
- end_time (se is_working = true)

Nessun altro campo deve influenzare il dirty:
- niente flag UI (loading, expanded, ecc.)
- niente conteggi calcolati
- niente ‚ÄúaffectedOrdersCount‚Äù (√® informativo)

------------------------------------------------
FONTE DI VERIT√Ä PER IL CONFRONTO (CRUCIALE)
------------------------------------------------

Il confronto NON deve usare ‚Äúi default frontend‚Äù come baseline.
La baseline di confronto √® SEMPRE quella fornita dal BACKEND.

Regola:
- initialSnapshot = risposta backend ‚Äúbaseline della settimana‚Äù

Se il backend restituisce:
1) Settimana con dati DB:
   - baseline = dati DB effettivi
   - Save deve essere disabled inizialmente (dirty=false)

2) Settimana senza dati DB (nessun working_day salvato):
   - baseline backend = ‚Äúnessuna configurazione persistita‚Äù (empty)
   - il backend pu√≤ comunque fornire ‚Äúdefault display‚Äù (per mostrare la pagina)
     MA questi default NON sono da considerarsi ‚Äúsalvati‚Äù
   - quindi:
     üëâ il draft iniziale (default mostrato) √® DIVERSO dalla baseline (empty)
     üëâ dirty deve partire true
     üëâ Save deve partire ENABLED (se settimana non passata)

OBIETTIVO:
- permettere all‚Äôadmin di ‚Äúsalvare i default‚Äù come prima configurazione della settimana

------------------------------------------------
COME RAPPRESENTARE LA BASELINE NELLO STATE
------------------------------------------------

In state.js devono esistere:

- baselineFromBackend
  - rappresenta la baseline della settimana restituita dal backend
  - pu√≤ essere:
    - { mode: "persisted", data: ... } se esistono dati DB
    - { mode: "empty", data: null } se non esistono dati DB

- draft
  - rappresenta ci√≤ che √® mostrato e modificabile in UI
  - se baseline √® empty, draft parte coi default (da backend o config)

- dirty
  - calcolato confrontando baseline vs draft

IMPORTANTE:
- non usare snapshot = draft al primo load nel caso baseline=empty,
  altrimenti dirty partirebbe false e Save resterebbe grigio (BUG).

------------------------------------------------
CALCOLO DIRTY (OBBLIGATORIO)
------------------------------------------------

Implementare una funzione pura, ad esempio:
computeDirty(baselineFromBackend, draft, today)

Regole:
- Se settimana passata ‚Üí dirty pu√≤ anche essere true, ma Save resta DISABLED comunque.
- Se baseline.mode == "persisted":
  - confrontare baseline.data vs draft solo sui campi salvabili.
- Se baseline.mode == "empty":
  - baseline √® ‚Äúnessun working_day persistito‚Äù
  - quindi dirty = true se draft contiene:
    - qualunque global var valorizzata (anche default)
    - qualunque giorno configurabile (anche tutti OFF)
  - in pratica: se l‚Äôadmin vede una configurazione ‚Äúready‚Äù, deve poterla salvare.

(Implementazione suggerita: normalizzare baseline empty come oggetto ‚Äúvuoto‚Äù e confrontare con draft normalizzato.)

------------------------------------------------
ABILITAZIONE/DISABILITAZIONE SAVE (REGOLA FINALE)
------------------------------------------------

Save deve essere ENABLED se e solo se:

- settimana NON passata
- e (dirty === true)

Inoltre:
- se settimana corrente:
  - dirty deve derivare solo da modifiche su giorni > oggi
  - (giorni <= oggi non devono poter modificare draft)

------------------------------------------------
DOPO SAVE RIUSCITO
------------------------------------------------

Quando il backend risponde con successo (200):
- il backend restituisce la nuova configurazione persistita della settimana
- aggiornare:
  - baselineFromBackend = { mode: "persisted", data: responseData }
  - draft = responseData (o view-model coerente)
  - dirty = false
- re-render

Se il backend risponde errore:
- mantenere draft
- mantenere dirty
- mostrare errore non bloccante (o loggare) senza corrompere lo state

------------------------------------------------
ERRORI DA EVITARE (CRITICI)
------------------------------------------------

- Non impostare initialSnapshot = draft sempre.
  (Nel caso baseline empty, sarebbe SBAGLIATO.)
- Non considerare campi UI nel confronto.
- Non abilitare Save solo perch√© √® avvenuto un evento.
- Non permettere che azioni su campi disabled modifichino draft.
- Non calcolare dirty nel render.

------------------------------------------------
DELIVERABLE
------------------------------------------------

1) Implementazione state + computeDirty
2) Logica Save enable/disable corretta
3) Gestione caso baseline empty (Save parte attivo)
4) Commenti in italiano:
   - perch√© baseline √® backend
   - perch√© baseline empty => dirty true
5) Checklist manuale di test:
   - settimana passata: Save sempre disabled
   - settimana con dati DB: Save disabled finch√© non cambio qualcosa
   - settimana futura senza DB: Save enabled subito
   - modifico e poi riporto tutto uguale: Save torna disabled
