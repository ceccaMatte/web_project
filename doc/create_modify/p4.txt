ğŸ“Œ PROMPT #4 â€” COMPONENTI UI
Ingredienti, Accordion, Time Slot (SOLO RENDERING)

In questo prompt devi implementare ESCLUSIVAMENTE componenti UI.
NON devi implementare logica di business.
NON devi fare fetch.
NON devi mutare lo state.

I componenti ricevono props, renderizzano, emettono eventi. Fine.

ğŸ§± REGOLE ARCHITETTURALI (NON NEGOZIABILI)
ğŸ“ POSIZIONE FILE

TUTTI i componenti devono stare in:

resources/js/components/


âŒ NON sotto pages/create-order
âŒ NON sotto pages/orders
âŒ NON dentro render.js

Devono essere riutilizzabili in qualsiasi pagina.

ğŸ§  RESPONSABILITÃ€ COMPONENTE

Un componente:

riceve dati via props

renderizza markup

emette eventi custom (onClick, onToggle, ecc)

Un componente NON PUÃ’:

sapere se siamo in create o modify

sapere se un ingrediente Ã¨ obbligatorio

sapere se un bottone Ã¨ disabilitato â€œperchÃ© manca qualcosaâ€

fare fetch

leggere lo state globale

Se lo fa â†’ Ã¨ SBAGLIATO.

ğŸ§© COMPONENTI DA REALIZZARE
1ï¸âƒ£ AccordionSection.component.js
Scopo

Gestire una sezione apribile/chiudibile (es. â€œBreadâ€, â€œMeatâ€, ecc).

Props
{
  id,
  title,
  isOpen,
  disabled,
  children
}

Regole

UNA SOLA sezione puÃ² essere aperta alla volta

se clicco una sezione:

emette onToggle(sectionId)

NON decide quale sezione chiudere

NON mantiene stato interno

ğŸ‘‰ La logica â€œchiudi le altreâ€ Ã¨ NELLO STATE / ACTIONS, non qui.

2ï¸âƒ£ IngredientItem.component.js

Props:

{
  id,
  name,
  category,
  selected,
  available
}


Regole UI:

se available === false: non selezionabile + stile â€œfinitoâ€

se available === true: selezionabile

se selected === true: evidenziato

âŒ NON esiste stato disabled
âŒ La UI non applica vincoli
âŒ La UI non decide regole di business

Eventi

onSelect(ingredientId)

onDeselect(ingredientId)

âŒ NON decide se Ã¨ selezionabile
âŒ NON rimuove altri ingredienti
âŒ NON conosce le regole â€œ1 breadâ€

3ï¸âƒ£ IngredientsGroup.component.js
Scopo

Renderizzare una categoria di ingredienti (Bread, Meat, ecc)

Props
{
  category,
  ingredients[],
  openSectionId
}

Comportamento

usa AccordionSection

passa isOpen = openSectionId === category

renderizza lista di IngredientItem

ğŸ‘‰ NON gestisce:

selezioni

validazioni

rimozioni automatiche

4ï¸âƒ£ TimeSlotItem.component.js
Scopo

Visualizzare UN time slot

Props
{
  id,
  timeLabel,
  available,
  selected,
  disabled
}

Regole

se available === false:

disabilitato

stile â€œfullâ€

se selected === true:

evidenziato

Eventi

onSelect(timeSlotId)

âŒ NON deseleziona altri slot
âŒ NON sa se siamo in create o modify

5ï¸âƒ£ TimeSlotList.component.js
Scopo

Renderizzare la lista degli slot

Props
{
  timeSlots[],
  selectedTimeSlotId
}

Regole

renderizza TimeSlotItem

nessuna logica di validazione

6ï¸âƒ£ SubmitOrderButton.component.js
Props
{
  mode,               // create | modify
  disabled,
  loading
}

Regole

testo cambia in base al mode

se disabled === true:

bottone disabilitato

se loading === true:

mostra spinner

âŒ NON decide quando Ã¨ disabilitato
âŒ NON fa submit

ğŸ”„ COMUNICAZIONE EVENTI

TUTTI i componenti:

emettono eventi

NON chiamano actions direttamente

NON importano lo state

Esempio:

element.dispatchEvent(
  new CustomEvent('ingredient:select', { detail: id })
);

ğŸ¨ STILE GRAFICO (OBBLIGATORIO)

DARK MODE ONLY

classi coerenti con Home / Orders

nessun light background

nessuna palette inventata

usa classi Tailwind giÃ  presenti nel progetto

Se lo stile non matcha, Ã¨ da rifare.

ğŸš« ERRORI DA NON COMMETTERE (ANCORA)

âŒ componenti con stato interno

âŒ accordion che si auto-gestisce

âŒ componenti che â€œdecidonoâ€

âŒ duplicazione markup

âŒ logica nei componenti

âœ… RISULTATO ATTESO

Alla fine di questo step:

i componenti sono stupidi

riutilizzabili

testabili

prevedibili

tutta la logica Ã¨ nello state/actions